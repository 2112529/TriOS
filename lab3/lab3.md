## 基本要求（思考题）


# swap_fifo.c文件中的核心函数

基于FIFO的页面替换算法主要按照先进先出的原则进行，从代码中我们可以看到与该算法直接相关的函数如下：

1. **_fifo_init_mm**: 初始化页面替换算法的数据结构。
    - 初始化一个双向链表`pra_list_head`。
    - 将这个链表地址赋值给`mm->sm_priv`以供其他函数使用。

2. **_fifo_map_swappable**: 当页面被标记为可以交换出去时，该页面会被添加到双向链表的尾部。
    - 获取到链表的头部`head`。
    - 将页面`page`对应的链表项`entry`添加到链表的尾部。

3. **_fifo_swap_out_victim**: 当需要选择一个页面进行替换时，会选择链表头部的页面（即最早进入的页面）。
    - 获取链表的头部`head`。
    - 从链表的头部移除页面，并将此页面的地址赋值给`ptr_page`。

4. **_fifo_check_swap**: 这个函数实际上是进行了一系列的页面访问和断言操作以检测FIFO页面置换算法是否正常工作，但它本身不是页面置换算法的一部分。

5. **_fifo_init**: 空函数，用于初始化。

6. **_fifo_set_unswappable**: 空函数，但在完整的上下文中可能用于设置某个页面为不可交换。

7. **_fifo_tick_event**: 空函数，但在某些页面替换算法中可能会根据定时器事件进行一些操作。


- 页面从被换入到被换出的过程中，主要经过`_fifo_map_swappable`和`_fifo_swap_out_victim`两个函数。
- `_fifo_map_swappable`负责当页面被换入时，将其添加到链表的尾部。
- `_fifo_swap_out_victim`负责当需要页面被换出时，选择链表头部的页面进行替换。


# swap.c中的核心函数


8. `swap_init`: 这个函数主要负责初始化整个swap系统。它首先初始化swap文件系统，然后选择页面替换算法（本例中选择的是clock算法，但题目要求是FIFO算法），并调用其初始化方法。

9. `swap_init_mm`: 它是用于初始化内存管理结构体的函数。当一个新的进程被创建时，它的内存管理结构体需要进行初始化，这个函数就被调用。

10. `swap_map_swappable`: 当一个页面首次被映射到虚拟地址时，或者被换入时，这个函数被调用。它告诉页面替换算法，该页面现在是可交换的。

11. `swap_tick_event`: 这个函数可能在每一个时钟中断时被调用，用于更新页面替换算法的状态。例如，在一些算法中，需要周期性地检查哪些页面是"老的"并应该被替换。

12. `swap_out`: 这是执行页面替换操作的核心函数。当物理内存不足时，这个函数被调用，它选择一个或多个页面进行换出操作。

   a. `sm->swap_out_victim`: 选择一个作为“受害者”的页面，即选择一个要被换出的页面。

   b. `swapfs_write`: 将所选择的页面写入swap磁盘。

   c. `free_page`: 释放该物理页面。

13. `swap_in`: 当某个被换出的页面被再次访问时，这个页面需要被换入。这个函数执行这一操作。

   a. `alloc_page`: 为被换入的页面分配一个新的物理页面。

   b. `swapfs_read`: 从swap磁盘读取页面内容。

14. `check_swap`: 这是一个测试函数，用于检查页面交换机制是否工作正常。


# vma.c文件中的核心函数

15. **find_vma**: 查找包含给定地址的虚拟内存区域(VMA)。如果找到，它将被缓存以优化将来的查找。

16. **check_vma_overlap**: 检查两个VMA是否重叠，并通过断言确保它们不重叠。

17. **insert_vma_struct**: 将一个新的VMA插入到mm结构体的VMA列表中，并确保没有重叠的VMA存在。

18. **mm_destroy**: 销毁一个mm结构体，并释放它的所有VMA。

19. **vmm_init**: 初始化虚拟内存管理并通过调用`check_vmm`来检查VMM的正确性。

20. **check_vmm**: 检查VMM的正确性。它将调用其他检查函数，并确保没有意外地消耗了额外的页面。

21. **do_pgfault**: 页面错误处理函数。当访问一个不存在的页面或违反页面权限时，会被调用。该函数首先查找触发错误的地址是否在一个VMA中。然后，它会尝试处理页面错误，要么是通过为地址分配一个新的页面（如果该地址是有效的），要么是通过从交换空间换入页面（如果开启了交换）。

22. **get_pte**: 获取一个页面表条目 (PTE)。如果需要，它还会为PTE创建一个新的页面表。

23. **pgdir_alloc_page**: 为给定的线性地址在指定的页面目录中分配一个新的页面，并设置适当的权限。



从代码中，我们可以看到`exception_handler`函数处理了多种异常，其中涉及到页面错误（page fault）的有三种：`CAUSE_LOAD_ACCESS`、`CAUSE_STORE_ACCESS`、`CAUSE_LOAD_PAGE_FAULT`和`CAUSE_STORE_PAGE_FAULT`。当这些异常发生时，都会调用`pgfault_handler`函数。

# trap.c文件的核心函数

24. **do_pgfault**: 这个函数是处理页面错误的核心，它会根据错误类型（读/写）和地址来确定应该如何处理。
   
25. **swap_in**: 通常用于将页面从交换空间（swap space）加载到物理内存。
   
26. **swap_out**: 用于将页面从物理内存移动到交换空间。在FIFO算法中，这通常意味着选择队列中最老的页面进行替换。
   
27. **page_replace**: 这是一个选择替换页面的函数，对于FIFO，它将选择队列的头部页面。
   
28. **enqueue_page**: 当页面首次加载到内存时或从交换空间加载回来时，它可能会被添加到队列的尾部。
   
29. **dequeue_page**: 当页面从物理内存被替换出去时，它会从队列中被移除。
   
30. **page_fault_alloc_page**: 当页面错误发生，并且需要分配一个新页面来满足请求时，这个函数可能会被调用。
   
31. **page_free**: 当页面不再需要时（例如，它已经被写回到磁盘并从队列中移除），这个函数会释放页面。
   
32. **map_page**: 一旦页面被加载到物理内存，它需要被映射到进程的地址空间。
   
33. **unmap_page**: 在页面从物理内存中被移除之前，它会从进程的地址空间中被取消映射。


#### 基本要求（思考题）

`get_pte`函数是在多级页表结构中用于获取或创建一个虚拟地址对应的页表项（Page Table Entry, PTE）的核心机制。该函数的主要工作流程是两级查找与可能的分配操作。

1. **两段代码的相似性**：代码中的两段结构非常相似，因为它们都在处理多级页表结构。第一段代码处理的是第一级页目录，而第二段代码处理的是第二级页表。在多级页表中，虚拟地址被分为多个部分，每个部分都用于索引页表的一个级别。两段代码都是根据虚拟地址的某个部分来索引页表，然后检查该条目是否存在。如果不存在并且需要创建新条目，则为其分配一个新页。这两段代码之所以看起来如此相似，是因为它们在逻辑上是等价的，只是操作的页表级别不同。

2. **查找与创建的合并**：`get_pte`函数中同时进行了页表项的查找和可能的创建。这种做法的优点在于提高效率。当需要获取页表项时，无需先调用一个查找函数，然后再调用一个创建函数。这种连续的操作在单一函数中更为高效，减少了额外的函数调用开销。但这样的设计也有其缺点。首先，这增加了函数的复杂性，因为它现在具有多重功能。其次，这限制了代码的模块化，如果未来需要只进行查找而不创建，这种设计可能不太灵活。

具体到代码细节：

- `pde_t *pdep1 = &pgdir[PDX1(la)];` 这行代码获取第一级页目录的条目。
- `if (!(*pdep1 & PTE_V))` 检查该条目是否有效，即是否已经有相应的映射。
- 在`if`语句中，如果条目无效并且需要创建新条目，就调用`alloc_page()`分配一个新页，然后设置其引用计数，得到其物理地址，并将新页清零。
- `*pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);` 这行代码设置第一级页目录的条目，使其指向新分配的页。

第二段代码的操作与第一段类似，只是它处理的是第二级页表。

在RISC-V架构中，虚拟内存到物理内存的映射使用了多级页表，其中`sv32`，`sv39`和`sv48`表示三种不同的页表深度模式。这些名称中的数字表示虚拟地址的位数。

1. **sv32**：该模式使用32位的虚拟地址空间，并具有两级页表。
2. **sv39**：该模式使用39位的虚拟地址空间，并具有三级页表。
3. **sv48**：该模式使用48位的虚拟地址空间，并具有四级页表。

首先，该`get_pte`函数主要用于获取或创建与给定虚拟地址`la`相关联的页表项。函数中的两段代码分别处理了页表的第一级和第二级，而返回的则是第三级的页表项地址。

对于`sv39`模式：
1. 第一段代码处理了第一级页目录，它使用`PDX1(la)`来索引页目录并获取或创建与其关联的页目录条目。
2. 第二段代码处理了第二级页目录，它使用`PDX0(la)`来索引页目录并获取或创建与其关联的页目录条目。
3. 最后，函数返回了第三级页表的地址，这是实际与给定虚拟地址`la`关联的页表项地址。

通过对比分析，可以发现以下几点：
1. **逻辑结构**：在`get_pte`函数中，对于每一级的处理逻辑结构都是相同的。这就是为什么看到的两段代码如此相似。如果是`sv48`模式，则会有三段相似的代码来处理前三级，再返回第四级的页表项地址。
2. **索引方法**：虽然每一级的处理逻辑相似，但它们用于索引页表的部分是不同的。这就是为什么第一段代码使用`PDX1(la)`，而第二段代码使用`PDX0(la)`的原因。
3. **分配新页**：如果在某级的页表中没有找到相应的条目，并且`create`标志被设置，则会为该级分配一个新页。
4. **物理地址和虚拟地址转换**：在操作页表时，需要频繁地在物理地址和内核虚拟地址之间进行转换。这就是为什么频繁使用`KADDR()`宏的原因。

## 练习 3：给未被映射的地址映射上物理页

对于本次实验，我们主要的任务就是完善dopgfault函数，我们首先对需要用的函数进行分析：

- swap_in(mm, addr, &page) : 首先使用alloc_pages函数分配一个内存页，然后使用get_pte()函数根据PTE中的swap条目的addr，找到磁盘页的地址，最后使用swapfs()函数将磁盘页的内容读入这个内存页（注意这里其实并没有实际的磁盘，只是将内存中的某一部分划分出来作为磁盘区，所以本质上其实就是内存中数据的交换），并将这个页给到page变量
- page_insert ：首先也是通过pgdir和addr使用get_pte()函数找到对应的页表项，判断状态位信息之后使用pte_create()函数建立页表项， 建立一个Page的phy addr与线性addr la的映射，然后使用tlb_invalidate()函数刷新TLB
- swap_map_swappable ： 设置页面可交换，这个函数就是页面之后算法内置的函数，主要的作用就是将上面得到的page添加到置换算法私有变量中维护的一个双链表，标记为页面也换出，为后面的页面置换提供数据结构的支持

结合pgfault函数的作用，我们最终补全的代码如下：

```C
swap_in(mm, addr, &page);//将addr（错误触发地址）所在的页检索到之后换到内存之中，并将维护的page结构体指针传递给page
page_insert(mm->pgdir, page, addr, perm);//为page对应的页面建立物理地址到虚拟地址之间的映射
swap_map_swappable(mm,addr,page,swap_in);//设置该换入的页面为可交换，供后面的算法使用
```

针对后面的三个问题的回答，我们给出的回答和思考如下：

1. 在页面置换算法过程中，找到需要换入的页面以及为换入页面建立物理地址到虚拟地址之间的映射需要使用get_pte()函数、pte_create()函数以及page_remove_pte（）函数，这些函数中都需要使用到页表项以及页目录项

2. 对于访存异常过程中硬件发挥的作用，我们做出总结主要是下面的内容：

   **保存当前执行上下文**：硬件会将引发异常的指令的PC（程序计数器）保存到`sepc`（异常程序计数器）中。

   **设置异常码和异常原因**：RISC-V 的`stval`寄存器会被加载为引起异常的异常地址（比如引起页错误的虚拟地址），而`scause`寄存器则会被设置为描述异常原因的值。

   **中断正常执行**：一旦异常发生，CPU 将停止当前执行的代码。

   **跳转到异常处理程序**：RISC-V CPU 将根据当前的权限模式和`stvec`寄存器（保存了异常处理程序的地址）的设置跳转到异常处理程序。

   **更新状态**：`sstatus`寄存器中的一些位可能会被更新，如 SPIE 位（保存先前的中断使能状态）和 SPP 位（保存先前的权限模式）。

3.`Page` 的全局变量数组中的每一项通常代表一个物理页面。数组的索引可以与物理页帧号（Physical Frame Number，简称 PFN）相对应，而数组中的实际 `Page` 结构可以存储关于该物理页面的各种信息，如引用计数、是否被分配等。

页目录项和页表项则存在于操作系统的虚拟内存管理部分。它们用于将虚拟地址映射到物理地址。页目录项指向一个页表，而页表项指向一个物理页帧。

所以，`Page` 数据结构数组与页表中的页目录项和页表项之间的对应关系是：

- 页表项中存储的物理地址（或物理页帧号）可以用来索引 `Page` 数据结构数组，从而找到与该物理地址对应的 `Page` 结构。
- 当我们知道一个 `Page` 数据结构，我们可以通过其在数组中的位置来计算其对应的物理页帧号，然后通过页表和页目录的机制将其映射到某个虚拟地址。

## 练习4：补充完成 Clock 页替换算法

我们的clock算法主要是根据FIFO算法进行改良得到的，**主要的区别就是对每一个新来的page我们对其处理的方式不同，同时新加一个状态位visited标记最近是否访问过，最终决定换出的思路也是不一样的**，我们的编程工作主要是体现在两个部分

```C
//_clock_map_swappable函数    
    list_entry_t *entry=&(page->pra_page_link);
    assert(entry != NULL && curr_ptr != NULL);
    list_add_before((list_entry_t*) mm->sm_priv,entry);
    page->visited = 1;
```

在这个函数里面，前面的处理都是一样，但是不同于FIFO算法每次都是使用list_add_after函数将新来的page插入到head的后面一个然后使用head-prv（因为每次插入都是插入到head的后面，所以最新的page永远在head-next,最先到来的page永远都在离head最远的位置，只需要使用list-prv函数就可以找到）来找到最先来到的页面，clock置换算法中使用list_add_before函数将新来的page插入到head之前，也就是双链表的尾部，同时设置标志位为1，标识当前页面最近被访问过

```C
//_clock_swap_out_victim函数
        struct Page *page = le2page(curr_ptr, pra_page_link);
        // 如果当前页面未被访问，则将该页面从页面链表中删除，并将该页面指针赋值给ptr_page作为换出页面
        if (page->visited==0) {
            *ptr_page=page;
            list_del(curr_ptr);
            cprintf("curr_ptr %p\n",curr_ptr);
            break;
        }
        // 如果当前页面已被访问，则将visited标志置为0，表示该页面已被重新访问
        else
        {
            page->visited = 0;
        }
```

随后在_clock_swap_out_victim中，我们主要的思路就是首先检查置换算法维护的双链表i是不是为空，如果是空的，说明没有可以换出的页面，输出提示信息之后直接转移到其它函数中，如果不为空，则遍历双链表，判断标志位，把第一个找到的visited==0的页面置换出去，同时从页面置换算法维护的双链表中删除，/如果当前页面已被访问，则将visited标志置为0，表示该页面已被重新访问。

clock算法和FIFO算法的差异已经在上面阐释编程过程的同时进行了阐释。

## challenge 要求（思考题）

在虚拟内存系统中，页表的设计和实现对于系统的性能和灵活性起到了关键的作用。通常，我们会看到分级页表作为一种常用的实现方式，但是在某些场景中，使用“一个大页”的方法也可能是有效的。以下是关于“一个大页”与分级页表的优势和风险的详细分析：

**“一个大页”方法的定义**：通常，在虚拟内存系统中，每页的大小都是固定的（如4KB）。但是，“一个大页”的方法实际上使用了更大的页大小，比如2MB或者更大，来减少页表的大小和复杂性。

### 优势与好处：

1. **简化的页表结构**：采用“一个大页”的方法可以极大地简化页表的管理和查找过程。不需要多级页表的遍历，减少了多级页表带来的性能开销。

2. **减少TLB缺失**：由于每个TLB条目能够映射更大的虚拟内存范围，因此可能会减少TLB缺失的次数，从而提高性能。

3. **连续的物理内存分配**：大页能够保证较大的连续物理内存分配，这对于某些应用程序和硬件操作可能是有益的，因为它们可能需要大量的连续内存。

4. **减少页表大小**：由于每个页表条目可以映射更大的内存范围，因此总体上需要的页表条目数量会减少，从而减少页表的大小和内存使用。

5. **优化大型数据集操作**：对于处理大型数据集的应用程序，使用大页可以减少页缺失和其他与页面管理相关的开销。

### 坏处与风险：

1. **内存浪费**：使用大页可能会导致内存浪费。例如，如果一个应用程序只需要使用部分大页中的一小部分，那么其余的内存就会被浪费。

2. **碎片化**：随着时间的推移，大页可能会导致内存碎片化，因为分配和释放大块的连续内存空间比小页更困难。

3. **缺乏灵活性**：与分级页表相比，大页方法缺乏灵活性。在分级页表中，不同级别的页表可以为不同大小的页提供支持，而大页方法则只为一种大小的页提供支持。

4. **难以处理小型任务**：对于需要少量内存的小型任务，大页可能并不是最佳选择，因为它可能导致大量的内存浪费。

5. **TLB压力**：尽管大页可以减少TLB缺失，但如果工作集大小变化较大，TLB可能会面临更大的压力，因为每个TLB条目都映射了更大的内存范围。

6. **与硬件的兼容性问题**：不是所有的硬件都支持大页，这可能会导致兼容性问题。

7. **页交换开销**：当物理内存不足，需要进行页交换时，大页导致交换的数据量变大，从而增加了交换的开销。

### 总结：

虽然“一个大页”的方法提供了简化的页表管理和可能的性能优势，但它也带来了内存浪费和碎片化等问题。选择使用大页还是分级页表应当基于应用程序的特定需求和目标平台的特点。在需要处理大型数据集或希望优化TLB性能的场景中，大页可能是有益的。然而，对于内存敏感或需要更大灵活性的应用程序，分级页表可能是更好的选择。

## challenge 要求（编程实现）： LRU 页面替换算法在C中的实现

# 算法思路：

1. **数据结构**：使用一个双向链表表示缓存。链表的头部存放最新使用的页面，而尾部存放最近最少使用的页面。

2. **查找操作**：
   - 当需要检查一个页面是否在缓存中时，遍历链表以查找该页面。
   - 如果该页面已经在缓存中（即在链表中），则将其从当前位置删除并移动到链表的头部，表示它现在是最新使用的页面。

3. **插入操作**：
   - 当缓存未满时，直接在链表头部添加新页面。
   - 如果缓存已满（即链表的大小达到了上限），则先从链表尾部删除一个页面（即最近最少使用的页面），然后再在链表头部添加新的页面。

4. **替换操作**：当需要将一个新的页面放入缓存，但缓存已满时，删除链表尾部的页面（即最近最少使用的页面），然后在链表头部添加新的页面。

5. **优化**：为了提高查找效率，可以使用哈希表与双向链表结合的方式实现LRU。哈希表用于存放页面与其在链表中的位置的映射，这样可以在O(1)的时间复杂度内判断一个页面是否在缓存中，并迅速找到其在链表中的位置。


- 当页面被访问或添加到缓存时，始终将其移动到链表的头部。
- 当需要替换页面时，总是从链表的尾部删除页面，因为它是最近最少使用的。
- 双向链表是实现这一策略的关键，因为它允许我们在O(1)的时间内从链表中删除一个节点，并在链表的头部或尾部添加一个节点。


### 数据结构和变量

- `list_entry_t pra_list_head;`：这是一个链表入口，表示LRU算法的主要数据结构，即页面列表。

### 主要函数

1. **_lru_init_mm**：此函数初始化`pra_list_head`链表并将`mm->sm_priv`设置为`pra_list_head`的地址。这样，通过内存控制结构`mm_struct`，我们可以访问LRU页面替换算法。

2. **_lru_map_swappable**：根据LRU算法，每当访问一个页面时，它都应该移动到`pra_list_head`队列的尾部，表示它是最近使用的。 

3. **_lru_swap_out_victim**：根据LRU算法，我们应该在`pra_list_head`队列前断开最近最少使用的页面的链接，然后将此页面的地址设置为`ptr_page`。

### 其他函数

- **_lru_init**、**_lru_set_unswappable** 和 **_lru_tick_event** 都是为特定需求（例如初始化、设置页面为不可交换或处理定时事件）而定义的函数，但在所提供的代码段中，这些函数的实现为空。

### 结构体

- `swap_manager swap_manager_lru`：这个结构体定义了与LRU算法相关的函数指针，以及该算法的名称。其中`.check_swap`使用了`_fifo_check_swap`，这意味着LRU和FIFO都共享某种检查交换的逻辑。

### 在vmm结构体中添加成员变量跟踪页面的访问过程

了在`vmm`结构体中跟踪页面访问以供LRU算法使用:

1. **增加跟踪成员**:
   
   首先，在`mm_struct`或`vma_struct`中增加一个跟踪页面访问的链表或数组。考虑到LRU需要知道哪个页面最久未使用，使用一个链表结构是最合适的。

   ```c
   struct mm_struct {
       ...
       struct list_head lru_page_list;
       ...
   };
   ```

   这里使用Linux内核提供的双向链表`list_head`结构。每次页面被访问，都会将其移至链表的前部。这样，链表尾部的页面就是最久未使用的页面。

2. **页面跟踪结构体**:
   
   为了存储页面的信息，可以创建一个新的结构体。

   ```c
   struct lru_page {
       struct list_head list; // 用于插入到mm_struct的lru_page_list中
       struct page *pg;      // 指向内核中的页面结构体
       unsigned long last_access_time; // 最后访问时间，可以使用jiffies
   };
   ```

3. **修改页面访问函数**:
   
   当页面被访问时，需要更新LRU链表。找到相关的页面访问函数（比如`handle_mm_fault()`）并修改它，每次访问页面时，都将对应的`lru_page`移至链表的前部。这可以使用Linux提供的`list_move_tail`函数。

   ```c
   struct lru_page *lpage = ...; // 找到被访问的页面的lru_page
   lpage->last_access_time = jiffies;
   list_move_tail(&lpage->list, &mm->lru_page_list);
   ```

4. **LRU接口**:
   
   为LRU算法提供一个接口，例如`get_lru_page()`，该函数返回最久未使用的页面。

   ```c
   struct page *get_lru_page(struct mm_struct *mm) {
       if (list_empty(&mm->lru_page_list))
           return NULL;
   
       struct lru_page *lpage = list_entry(mm->lru_page_list.prev, struct lru_page, list);
       return lpage->pg;
   }
   ```

5. **页面释放**:

   当页面被释放或替换时，确保也从LRU链表中移除对应的`lru_page`结构体。

