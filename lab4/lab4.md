
#### 问题重述

---

### 7.1.2.2.1.2 练习 1：分配并初始化一个进程控制块（需要编码）

- **任务**: `alloc_proc` 函数（位于 `kern/process/proc.c` 中）负责分配并返回一个新的 `struct proc_struct` 结构，用于存储新建立的内核线程的管理信息。您需要对这个结构进行最基本的初始化。

- **初始化内容**:
  - `proc_struct` 结构中的成员变量至少包括：`state`/`pid`/`runs`/`kstack`/`need_resched`/`parent`/`mm`/`context`/`tf`/`cr3`/`flags`/`name`。
  - 请在实验报告中简要说明您的设计实现过程。

- **问题**:
  - 请说明 `proc_struct` 中 `struct context context` 和 `struct trapframe *tf` 成员变量的含义和在本实验中的作用？

---

### 7.1.2.2.1.3 练习 2：为新创建的内核线程分配资源（需要编码）

- **任务**: 创建一个内核线程需要分配和设置很多资源。`kernel_thread` 函数通过调用 `do_fork` 函数完成具体内核线程的创建工作。`do_kernel` 函数会调用 `alloc_proc` 函数来分配并初始化一个进程控制块，但 `alloc_proc` 只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。`ucore` 一般通过 `do_fork` 实际创建新的内核线程。

- **执行步骤**:
  - 调用 `alloc_proc`，首先获得一块用户信息块。
  - 为进程分配一个内核栈。
  - 复制原进程的内存管理信息到新进程（但内核线程不必做此事）。
  - 复制原进程上下文到新进程。
  - 将新进程添加到进程列表。
  - 唤醒新进程。
  - 返回新进程号。

- **问题**:
  - 请说明 `ucore` 是否做到给每个新 `fork` 的线程一个唯一的 id？请说明您的分析和理由。

---

### 7.1.2.2.1.4 练习 3：编写 proc_run 函数（需要编码）

- **任务**: `proc_run` 用于将指定的进程切换到 CPU 上运行。

- **执行步骤**:
  - 检查要切换的进程是否与当前正在运行的进程相同，如果相同则不需要切换。
  - 禁用中断。可以使用 `/kern/sync/sync.h` 中定义的宏 `local_intr_save(x)` 和 `local_intr_restore(x)` 来实现关、开中断。
  - 切换当前进程为要运行的进程。
  - 切换页表，以便使用新进程的地址空间。`/libs/riscv.h` 中提供了 `lcr3(unsigned int cr3)` 函数，可实现修改 CR3 寄存器值的功能。
  - 实现上下文切换。`/kern/process` 中已经预先编写好了 `switch.S`，其中定义了 `switch_to()` 函数。可实现两个进程的 `context` 切换。
  - 允许中断。

- **问题**:
  - 在本实验的执行过程中，创建且运行了几个内核线程？

---

继续补充 Lab4 模块的挑战任务内容：

---

### 7.1.2.2.1.5 扩展练习 Challenge：

- **任务**: 说明语句 `local_intr_save(intr_flag);....local_intr_restore(intr_flag);` 是如何实现开关中断的？

- **实现机制**:
  - `local_intr_save(intr_flag)` 和 `local_intr_restore(intr_flag)` 是操作系统中常用的中断管理宏。这两个宏的作用是保护代码块免受中断的影响，确保代码块中的操作可以连续执行而不被中断打断。
  - `local_intr_save(intr_flag)` 用于保存当前中断状态并禁用中断。这样做的目的是防止在执行重要的、不可中断的代码段时发生中断。
  - `intr_flag` 变量用于保存当前的中断状态。这意味着如果在调用 `local_intr_save` 之前中断是启用的，那么这个状态会被保存在 `intr_flag` 中。
  - 在代码块执行完毕后，`local_intr_restore(intr_flag)` 会根据 `intr_flag` 中保存的原始状态来恢复中断。如果原始状态是启用的，则中断会被重新启用；如果原始状态是禁用的，则中断继续保持禁用状态。
  - 这种机制非常重要，因为它允许操作系统维护中断的一致性，避免在执行关键代码时发生不可预知的中断，这对操作系统的稳定性和可靠性至关重要。

- **实践意义**:
  - 在操作系统中，特别是在内核级别的编程中，经常需要处理共享资源或执行关键操作，这些操作必须连续完成，不能被中断打断。
  - 通过使用这些宏，开发者可以确保在执行关键任务时，系统不会响应外部中断，从而避免了潜在的竞争条件和不一致性问题。
  - 这种机制也使得操作系统能够在执行重要任务时保持控制权，防止系统的不稳定和安全风险。

- **应用举例**:
  - 例如，在操作系统处理进程切换或进行内存管理的过程中，通常会使用这些宏来保证这些操作的原子性和一致性。
  - 另一个例子是在设备驱动程序中，当需要保证对设备的访问不被其他进程或中断干扰时，也会使用这些宏。


#### 练习 1的实现：分配并初始化一个进程控制块（需要编码）

#### 1. 更详细的 `proc_struct` 分配
`alloc_proc` 函数不仅负责创建一个新的 `proc_struct` 实例，它还需要确保分配的内存空间符合操作系统的内存管理要求。这包括对内存对齐的处理，以及确保内存页的正确分配和回收。在这个过程中，还需要考虑错误处理，比如内存分配失败的情况。

#### 2. 全面的成员变量初始化
- `state`: 应确保进程初始状态正确，例如新创建的进程可能首先处于就绪状态。
- `pid`: 分配唯一的进程标识符，这可能涉及到维护一个全局的 PID 计数器。
- `runs`: 初始设置为 0，表示进程尚未被调度。
- `kstack`: 分配内核栈空间，并确保正确对齐和初始化。
- `need_resched`: 初始设置为 false，表示进程创建时不需要立即调度。
- `parent`: 如果进程是由另一个进程创建的，需要设置此项。
- `mm`: 对于内核线程，此项通常为 null，因为它们共享内核的地址空间。
- `context`: 初始化为一个空的上下文，以备后续填充。
- `tf`: 同样初始化为空，直到线程进入内核态时才被设置。
- `cr3`: 设置为当前的页表地址。
- `flags`: 设置进程的初始标志。
- `name`: 赋予新进程一个名称。

#### 3. 复杂的上下文和陷阱帧处理
- `context`: 在线程首次运行时，需要设置其初始寄存器值，例如指令指针（IP）和栈指针（SP）。
- `tf`: 需要考虑从用户态到内核态的转换，这涉及到保护用户态下的寄存器状态和其他关键信息。

### 实验代码实现

```c
// 示例伪代码，可能需要根据实际环境调整

proc_struct *alloc_proc(void) {
    // 分配 proc_struct
    proc_struct *proc = kmalloc(sizeof(proc_struct));
    if (proc == NULL) {
        return NULL; // 处理内存分配失败
    }

    // 初始化成员变量
    proc->state = PROC_UNINIT;
    proc->pid = get_new_pid(); // 获取新的 PID
    proc->runs = 0;
    proc->kstack = alloc_kstack(); // 分配内核栈空间
    proc->need_resched = false;
    proc->parent = NULL; // 或者设置为当前进程
    proc->mm = NULL; // 内核线程不需要独立的内存空间
    memset(&proc->context, 0, sizeof(context)); // 初始化上下文
    proc->tf = NULL; // 初始化陷阱帧
    proc->cr3 = get_cr3(); // 获取当前的页表地址
    proc->flags = 0; // 初始化标志
    strncpy(proc->name, "new_process", PROC_NAME_LEN); // 设置进程名

    return proc;
}

```

通过这个更为详细的实验思路和代码实现，我们可以更深入地理解操作系统内核在进程创建和初始化方面的复杂性。特别是内存管理、进程状态管理、以及进程上下文和陷阱帧的处理，都是理解操作系统核心功能的关键部分。

#### 练习 2的实现：为新创建的内核线程分配资源（需要编码）

练习 2 的目标是为新创建的内核线程分配资源。涉及操作系统核心功能如内存管理、进程复制、上下文设置等。

### 实验思路与步骤

#### 1. **理解内核线程创建的基本流程**
创建内核线程涉及到多个关键步骤，包括进程控制块的分配、资源的分配和初始化、以及父子进程关系的建立等。理解这些步骤的顺序和目的是实验的首要任务。

#### 2. **使用 `do_fork` 函数创建线程**
`do_fork` 函数是实验的核心，它用于复制当前内核线程，创建一个新的线程。这个过程包括：
   - 调用 `alloc_proc` 函数分配一个新的进程控制块（`proc_struct`）。
   - 为新进程分配内核栈。
   - 复制父进程的状态到新进程，包括内存管理信息和上下文。
   - 将新进程添加到进程列表并唤醒它。

#### 3. **深入理解 `alloc_proc` 和 `do_fork` 的关系**
`alloc_proc` 为新进程分配了进程控制块，但这还不足以让进程运行。`do_fork` 在此基础上进一步配置资源，使新线程成为独立的执行单元。

#### 4. **分配内核栈**
内核栈是运行在内核态的线程所用的栈。它是线程私有的，用于存放内核态函数的局部变量、返回地址等。

#### 5. **复制父进程状态**
包括内存管理信息和进程上下文。对于内核线程，通常不需要复制整个内存空间（因为它们共享内核的地址空间），但需要复制寄存器状态、栈状态等。

#### 6. **添加进程到进程列表并唤醒**
将新创建的进程添加到系统的进程列表中，并将其状态设置为就绪，使得调度器可以选择它执行。

#### 7. **返回新进程的进程号**
作为创建过程的最后一步，返回新进程的标识符。

### 代码实现

```c
// 此代码假设已经实现了相关依赖的函数和数据结构

int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {
    // 分配新的进程控制块
    struct proc_struct *proc = alloc_proc();
    if (!proc) {
        return -E_NO_MEM;
    }

    proc->parent = current; // 设置父进程
    proc->flags = clone_flags;

    // 分配内核栈
    if (setup_kstack(proc) != 0) {
        goto bad_fork_cleanup_proc;
    }

    // 复制父进程的状态（对于内核线程，主要是复制寄存器等状态）
    if (copy_thread(proc, stack, tf) != 0) {
        goto bad_fork_cleanup_kstack;
    }

    bool intr_flag;
    local_intr_save(intr_flag);

    // 添加新进程到进程列表并唤醒
    {
        proc->pid = get_pid();
        list_add(&proc_list, &(proc->list_link));
        wakeup_proc(proc);
    }

    local_intr_restore(intr_flag);

    // 返回新进程的 PID
    return proc->pid;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    return -E_NO_FREE_PROC;
}
```

### 详细解释

- `alloc_proc` 调用：首先调用 `alloc_proc` 来创建一个新的 `proc_struct` 实例。这一步

是创建新进程的前提，为之后的资源分配提供了基础。

- 内核栈分配：`setup_kstack` 用于为新进程分配内核栈。内核栈是每个进程在内核模式下执行时使用的栈空间，它是进程隔离的重要部分。

- 状态复制：`copy_thread` 负责复制父进程的状态到新进程。这包括寄存器状态、程序计数器等。这一步对于保证新进程能够正确运行至关重要。

- 添加进程并唤醒：新进程被添加到系统的进程列表中，并设置为就绪状态，使得它能够被调度器选中并运行。

- 错误处理：在分配资源的过程中，如果发生任何错误（如内存分配失败），需要进行适当的清理工作，避免资源泄露。


#### 练习 3的实现：编写 proc_run 函数（需要编码）

练习 3 要求实现 `proc_run` 函数，该函数用于将指定的进程切换到 CPU 上运行。这个任务是操作系统进程管理和调度的关键部分，涉及到中断处理、进程状态管理、上下文切换等核心概念。以下是对实验思路和实现过程的详细描述，以及相应的完整代码实现。

### 实验思路与过程

#### 1. 进程切换的前提条件
首先，`proc_run` 函数需要判断是否真的需要进行进程切换。如果目标进程已经是当前运行的进程，则不需要切换。这个判断减少了不必要的上下文切换，从而提高系统效率。

#### 2. 中断处理
在进行进程切换之前，需要先禁用中断。这是为了防止在切换过程中发生中断，从而导致系统状态不一致或产生竞态条件。使用 `local_intr_save(x)` 和 `local_intr_restore(x)` 宏来分别禁用和恢复中断。这些宏通常会保存中断状态，并在恢复中断时恢复之前的状态。

#### 3. 切换当前进程
将当前进程切换为目标进程，这涉及到更新当前进程的全局指针和相关状态信息。在切换过程中，还需要处理与进程状态相关的其他信息，例如进程计数器、进程优先级等。

#### 4. 页表切换
在多任务操作系统中，每个进程可能有自己的地址空间。因此，切换进程时需要切换页表，确保新的进程能够访问其自己的地址空间。这通常通过修改 CR3 寄存器来实现。

#### 5. 上下文切换
最关键的一步是实现两个进程的上下文切换。上下文包括寄存器集合、程序计数器等。`switch_to()` 函数用于保存当前进程的上下文，并加载新进程的上下文。

#### 6. 中断恢复
最后，在进程切换完成后，恢复之前保存的中断状态。这样，新的进程可以在一个安全的环境下运行。

### 详细代码实现

```c
// 示例代码，需要根据实际环境进行调整

void proc_run(proc_struct *proc) {
    if (proc != current) {
        // 保存当前中断状态并禁用中断
        bool intr_flag;
        local_intr_save(intr_flag);

        // 更新当前进程状态
        if (current) {
            current->state = PROC_RUNNABLE;
        }
        proc->state = PROC_RUNNING;
        current = proc;

        // 切换页表
        lcr3(proc->cr3);

        // 上下文切换
        switch_to(&(current->context), &(proc->context));

        // 恢复中断
        local_intr_restore(intr_flag);
    }
}


```

这个实验涉及到操作系统核心的进程调度机制，特别强调了中断处理和上下文切换的重要性。通过实现 `proc_run` 函数，可以深入理解操作系统如何在多个进程间高效、安全地切换，保证系统的稳定性和响应性。这也体现了现代操作系统管理复杂硬件和多任务环境的能力。

对于 Lab4 的挑战练习，即分析 `local_intr_save(intr_flag);....local_intr_restore(intr_flag);` 语句的实现和功能，我们可以从中断处理的基本理论入手，逐步深入到 ucore 操作系统的具体实现中。

### 实验思路

#### 1. 理解中断和中断处理的基本概念
- **中断的定义**: 在操作系统中，中断是指处理器接收到来自硬件或软件的信号，提示发生了一个事件，需要暂停当前执行的任务，转而去执行一个高优先级的任务（即中断处理程序）。
- **中断处理的重要性**: 中断处理是操作系统设计中的核心部分，它允许操作系统响应外部事件，保证系统资源的有效管理和程序的正确执行。

#### 2. 了解 ucore 中断处理机制的概述
- **ucore 的中断处理框架**: ucore 中的中断处理涉及到多个组件，包括中断控制器、中断服务程序（ISR），以及与中断相关的各种寄存器和数据结构。

#### 3. 深入 `local_intr_save` 和 `local_intr_restore` 函数
- **函数的作用**: 这两个函数通常用于开启和关闭本地中断，保证特定代码段的原子性执行。
- **实现机制**: 通常通过修改处理器状态寄存器中的中断使能位来实现。

### 实验过程

#### 1. 分析中断使能和禁用的原理
- **中断使能位**: 处理器的状态寄存器中通常有一个位用于控制是否允许中断。当这个位被设置时，处理器可以响应中断；当这个位被清除时，处理器将忽略大多数中断。
- **中断禁用的必要性**: 在某些操作，如访问共享资源或修改关键数据结构时，需要禁用中断以防止并发访问导致的数据不一致。

#### 2. 探究 `local_intr_save` 和 `local_intr_restore` 的实现
- **保存和恢复中断状态**: `local_intr_save` 函数需要保存当前中断状态，并禁用本地中断。`local_intr_restore` 函数则需要恢复先前保存的中断状态。
- **具体实现**: 在 ucore 中，这些函数可能通过读取、修改和恢复处理器状态寄存器中的中断使能位来实现。

#### 3. 理解 ucore 的中断处理流程
- **中断发生时的行为**: 当中断发生时，处理器首先完成当前指令的执行，然后根据中断向量表跳转到相应的中断服务程序。
- **中断服务程序的作用**: 中断服务程序负责处理中断，它可能涉及保存和恢复处理器状态、处理中断原因、重新调度等。

#### 4. 实践中断禁用和恢复
- **代码实现**: 分析和实现 `local_intr_save` 和 `local_intr_restore` 函数，确保它们能够正确地保存、禁用和恢复中断。
- **测试**: 编写测试代码，验证在执行关键代码段时，通过这两个函数确实可以防止中断的干扰。

#### 5. 挑战部分的实现和测试
- **挑战实现**: 在 ucore 中实现一个示例，该示例展示了如何使用 `local_intr_save` 和 `local_intr_restore` 来保护关键代码段不受中断影响。
- **测试挑战**: 验证实现的正确性，确保在关键代码段执行期间，中断不会被响应。

