# Lab2实验报告

[TOC]

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

## 练习0：填写已有实验

本实验依赖实验1。请把你做的实验1的代码填入本实验中代码中有“LAB1”的注释相应部分并按照实验手册进行进一步的修改。具体来说，就是跟着实验手册的教程一步步做，然后完成教程后继续完成完成exercise部分的剩余练习。

---

## 练习1：理解first-fit 连续物理内存分配算法（思考题）
first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 你的first fit算法是否有进一步的改进空间？

**分析：**

（1）在init.c函数中调用init_pmm_manager();函数实现物理内存管理器的初始化，通过指针进行应用**实现pmm的实例化**（类似于C++中的虚函数），然后调用pmm结构体中的pmm_manager->init();进行真正的初始化操作。

（2）接下来程序执行流到了**default_init函数**中，该函数主要执行两个功能：

- 初始化全局变量nr_free记录可用的物理页面数量
- 将list_entry_t结构体初始化，作为存储页面的入口点

（3）随后开始执行**default_init_memmap函数**，该函数用来初始化一个block，首先是初始化block中的每一个页，p->flags 应该设置 PG_property 位：如果此页是空闲的并且不是自由块的第一页，p->property 应该设置为0，如果此页是空闲的并且是自由块的第一页，p->property 应该设置为块的总数，p->ref 应该是0，因为现在p是空闲的，没有引用。初始化之后我们使用 p->page_link 将此页链接到 free_list（例如：list_add_before(&free_list, &(p->page_link));），最后计算自由内存块的数量：nr_free+=n。

**函数调用关系图：kern_init --> pmm_init-->page_init-->init_memmap--> pmm_manager->init_memmap。**

（4）当我们完成了内存页 的初始化之后，就开始执行分配与释放函数，分别对应着**default_alloc_pages函数**以及**default_free_pages函数**。

（5）在**default_alloc_pages函数**中，使用`list_entry_t le = &free_list;`初始化一个列表条目指针`le`，并使用`while`循环遍历自由列表，检查`p->property`（记录自由块的数量）是否大于或等于n。如果是，这意味着我们找到了一个合适大小的自由块，一旦找到合适的自由块，函数会执行以下操作：

- 设置页面的某些标志位：`PG_reserved = 1`表示该页面已被保留，`PG_property = 0`表示该页面不再是自由块的一部分。
- 从`free_list`中解除链接这些页面。
- 如果`p->property > n`，这意味着自由块的大小大于请求的n，因此我们需要重新计算剩余自由块的大小。例如，使用`le2page(le,page_link)->property = p->property - n;`来更新剩余自由块的大小。
- 重新计算`nr_free`，这是所有自由块的剩余数量。
- 返回找到的自由块的地址`p`。

如果函数在自由列表中找不到大小至少为n的自由块，它将返回`NULL`。

（6）在**default_free_pages函数**中，首先根据撤回块的基地址，搜索自由列表，从低到高的地址找到正确的位置，并插入页面。随后充重置页面，`p->ref`应该被重置，因为现在没有任何引用指向这个页面。`p->flags`也应该被更新，特别是`PageProperty`标志，以表示这个页面现在是一个自由块的一部分。随后函数会尝试合并低地址或高地址的块。这一步是为了减少内存碎片化，确保大块的连续内存可用。期间也会进行页面参数的更新。

对于first fit可以改进的地方，我们做出的思考主要是以下几点：

- **合并逻辑**：在`default_free_pages`中，存在两次合并逻辑，一次是在添加到自由列表之前，一次是在之后。为了简化代码，我们考虑将这两次合并逻辑合并为一个函数
- **性能**：对于大型的自由列表，线性搜索可能会变得很慢。我们考虑使用更加高效的数据结构如平衡树或跳表，来加速搜索。
- **锁**：考虑到多线程的需要，我们考虑在修改自由列表或页面属性时使用锁，以确保线程安全。

---

## 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：

- 你的 Best-Fit 算法是否有进一步的改进空间？

**分析：**所谓的bestfit算法，其实就是将空闲分区链中的空闲分区按照空闲分区由小到大的顺序排序，从而形成空闲分区链。每次从链首进行查找合适的空闲分区为作业分配内存，这样每次找到的空闲分区是和作业大小最接近的，形成所谓“最佳”匹配。

具体实现的过程中，**`best_fit_init`**函数以及**`best_fit_init_memmap`**函数、**`best_fit_free_pages`**都是和FirstFit函数大同小异，主要的核心改进体现在**`best_fit_alloc_pages`**函数中

在**`best_fit_alloc_pages`**函数中：我们通过下面的while循环，不断迭代对比best_size和p->property从而实现最终找到大小最相近也就是最合适的块。

```
while ((le = list_next(le)) != &free_list) {
        struct Page *p = le2page(le, page_link);
        if (p->property >= n && p->property < best_size) {
            best_size = p->property;
            page = p;
        }
    }
```

对于该方式的改进，我们做出的思考主要是以下几点：

- 类似于前面firstfit算法相关的数据结构以及线程锁的相关改进仍然适用
- 当前的实现在分配后可能会将剩余的部分添加回自由列表。但是，如果这个剩余的部分紧邻另一个自由块，可以考虑立即合并它们，而不是等待`best_fit_free_pages`函数来做这个工作。
- `best fit`策略可能会导致更多的内存碎片化，因为它总是试图找到最接近请求大小的块。可以考虑实现一种混合策略，例如，在某些情况下使用`best fit`，在其他情况下使用`first fit`或`next fit`。

---

## 扩展练习Challenge1：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

---


### 1.伙伴系统概述

伙伴系统算法基于二进制指数的思想，即所有可用的空闲块大小都是2的幂次。当一个请求到来时，系统选择大小最接近且大于请求大小的块来满足该请求。为了支持快速的合并和分配，伙伴系统将相同大小的空闲块维护在独立的链表中。

buddy_system 数据结构的实现（仅仅定义了数据结构并进行验证，验证符合buddy_system的全部功能和特性，但是对时间复杂度的优化程度不够，因为使用了递归进行处理）

### 2.代码功能描述

#### （1）基本数据结构

- **MAX_ORDER**: 定义最大的伙伴大小的级别。
- **free_lists**: 为每个可能的块大小维护一个空闲块链表。
- **Page**: 表示内存中的一个页面或块。

#### （2）伙伴系统的辅助函数

- **order_of(size_t n)**: 给定一个大小n，计算对应的伙伴系统中的级别。
- **calculate_order(size_t size)**: 类似于order_of，计算块大小对应的级别。
- **find_buddy(...)**: 对于给定的内存块和它的大小级别，找到它的伙伴块。
- **is_buddy_free(...)**: 检查伙伴块是否空闲。
- **merge(...)**: 合并两个伙伴块为一个更大的块。

#### （3）内存分配函数

- **buddy_system_default_alloc_pages(size_t n)**: 分配大小为n的块。首先，该函数计算所需块的级别，然后从相应的空闲链表中查找块。如果在当前级别找不到，它会尝试在更高级别找。一旦找到合适的块，它可能需要将该块分成更小的块来满足请求。

#### （4）内存释放函数

- **buddy_system_default_free_pages(struct Page* base, size_t n)**: 释放给定块并尝试与其伙伴合并。该函数首先将块添加回其大小级别的空闲链表中，然后尝试找到其伙伴并与之合并，以此类推，直到不能再合并为止。

#### （5）内存映射初始化函数

- **buddy_system_default_init_memmap(...)**: 初始化内存映射。它遍历所有页面，设置每个页面的标志和属性，然后将基本页面添加到空闲链表中。

### 3.伙伴系统实现方法

伙伴系统的核心在于块的分配和释放过程。

- **分配**: 当一个请求到来时，伙伴系统首先确定满足该请求的最小块大小级别。然后，它在该级别的空闲链表中查找可用块。如果没有找到，它会移到更高的级别并继续查找，直到找到一个可用块或超出最大级别为止。一旦找到合适的块，伙伴系统可能需要将该块分成更小的块，直到满足请求。
  
- **释放**: 当块被释放时，伙伴系统首先尝试找到该块的伙伴。如果伙伴也是空闲的，那么这两个块可以合并为一个更大的块，然后再次尝试与新的伙伴合并，以此类推。

总的来说，这段代码提供了伙伴系统算法的一个简单但完整的实现。它高效地支持动态内存分配和释放，而不会产生过多的外部碎片。

## 扩展练习Challenge2：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

---

### 1.SLUB算法原理

SLUB是Linux内核的内存分配器之一，专为分配小块内存而设计。其主要特点是提供高效、无碎片的内存分配，减少内存浪费。

### 2.数据结构描述

#### （1）kmem_cache_node
- `partial`: 保存部分使用的slab的链表。
- `full`: 保存完全使用的slab的链表。
- `free_objects`: 该节点中的空闲对象数量。

#### （2）kmem_cache
- `object_size`: 单个对象的大小。
- `num`: 每个slab(一页内存)可以容纳的对象数量。
- `partial`: 保存部分使用的slab的链表。
- `full`: 保存完全使用的slab的链表。
- `node`: 关联的内存缓存节点。

#### （3）slab_page
- `cache`: 关联的内存缓存。
- `free_objects`: slab中的空闲对象数量。
- `list`: 用于将slab连接到部分使用或完全使用的链表。
- `free_pointer`: 指向slab中第一个可用对象的指针。

### 3.主要函数和功能描述

- #### page2kva 和 kva2page
  转换物理页面和内核虚拟地址。这是在内核地址空间和物理地址空间之间进行转换的基本函数。

- #### kmem_cache_grow
  当一个内存缓存中没有可用的空闲对象时，此函数用于增加一个新的slab。它从伙伴系统中请求一个新页面，并将其初始化为一个空的slab。

- #### kmem_cache_init
  初始化给定大小的内存缓存，设置对象大小，计算每个slab可以容纳的对象数量，并初始化slab链表。

- #### kmem_cache_alloc
  从给定的内存缓存中分配一个对象。如果没有可用的对象，则会尝试增长该缓存。

- #### kmem_cache_free
  释放一个对象，返回到其所属的内存缓存。如果slab现在有可用的空间，则可能将其移回到部分使用的列表。

- #### slub_init
  SLUB的初始化函数，用于初始化全局和默认的内存缓存。

- #### slub_alloc_pages 和 slub_free_pages
  这两个函数提供了从SLUB中分配和释放页面的功能。对于多页请求，它们直接使用伙伴系统。

- #### slub_init_memmap
  在系统启动时，这个函数初始化物理内存映射，为每个页面设置一个slab结构。

- #### slub_nr_free_pages
  计算当前空闲的页面数量。


### 4.SLUB的工作原理

#### （1）分配
当请求一个对象时，SLUB首先查找有没有部分使用的slab可以满足此请求。如果没有，则增加一个新的slab。一旦找到一个slab，SLUB会从中分配一个对象，并更新slab的状态。

#### （2）释放
当释放一个对象时，SLUB将其返回到所属的slab。如果slab现在有可用空间，则可能会将其从完全使用的列表移至部分使用的列表。

#### （3）优化
SLUB通过上述的分配和释放策略，确保内存分配高效、无碎片，从而避免浪费。

## 扩展练习Challenge3：硬件的可用物理内存范围的获取方法（思考题）
  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？

### 1.内存探测方法

内存探测是一种古老而原始的技术，操作系统通过它来尝试确定物理内存的界限。在这种方法中，操作系统会尝试访问递增的物理地址，直到遇到不能访问的地址为止。理论上，第一个出错的地址应该是RAM之外的地址。

**以下是基于C语言的简单内存探测方法：**

```c
#include <stdio.h>
#include <setjmp.h>
#include <signal.h>

#define PAGE_SIZE   4096    // 假设页面大小为4KB
#define MAX_MEM     0xFFFFFFFF  // 假设最大可探测内存为4GB

static jmp_buf env;

void segfault_handler(int signo) {
    longjmp(env, 1);
}

int main() {
    unsigned long addr = 0;
    char *ptr;

    signal(SIGSEGV, segfault_handler);

    while (addr < MAX_MEM) {
        if (setjmp(env) == 0) {
            ptr = (char*) addr;
            char value = *ptr;  // 尝试读取此地址
        } else {
            printf("Memory access failed at address: 0x%lX\n", addr);
            break;
        }
        addr += PAGE_SIZE;
    }

    printf("Estimated physical memory size: %lu MB\n", addr / (1024*1024));
    return 0;
}

# 利用MMU进行内存探测

内存管理单元（MMU）是现代计算机中的关键部件，支持虚拟内存和地址隔离。利用MMU的特性，我们可以尝试确定系统的物理内存界限。

## 方法

以下是一个简单的C语言方法，它通过设置页表和捕获由MMU产生的页错误来确定物理内存的界限：

```c
#include <stdio.h>
#include <setjmp.h>
#include <signal.h>

#define PAGE_SIZE   4096    // 假设页面大小为4KB
#define MAX_MEM     0xFFFFFFFF  // 假设最大可探测内存为4GB

static jmp_buf env;

void page_fault_handler(int signo) {
    longjmp(env, 1);
}

int main() {
    unsigned long addr = 0;
    char *ptr;

    signal(SIGSEGV, page_fault_handler);

    while (addr < MAX_MEM) {
        if (setjmp(env) == 0) {
            ptr = (char*) addr;
            char value = *ptr;  // 尝试读取此地址
        } else {
            printf("Memory access failed at address: 0x%lX\n", addr);
            break;
        }
        addr += PAGE_SIZE;
    }

    printf("Estimated physical memory size: %lu MB\n", addr / (1024*1024));
    return 0;
}
```

### 2.利用MMU

内存管理单元（MMU）是现代计算机架构中的核心部件。它主要负责地址转换，将虚拟地址转换为物理地址。这一功能为实现虚拟内存，地址隔离以及其他关键的内存管理任务提供了基础。由于MMU的这种核心性质，它也可以用于探测物理内存的范围。

利用MMU进行内存探测的基本思想是尝试访问超出当前已知物理内存范围的虚拟地址，并依赖于MMU生成的异常来判定是否超出了实际的物理内存范围。以下是这种方法的基本步骤：

1. 首先，确保操作系统设置了基本的页表结构，并可以捕获由MMU生成的异常，例如页错误。
2. 然后，选择一个虚拟地址，并尝试访问它。
3. 如果该地址映射到一个有效的物理页，该访问将成功，并且可以继续探测下一个地址。
4. 如果该地址没有映射到任何物理页，MMU会触发一个页错误。操作系统可以捕获这个错误，从中得知已经超出了物理内存的范围。
5. 重复此过程，直到找到物理内存的边界。

### 3.利用硬件寄存器和配置表进行物理内容空间检测

1. **识别并访问寄存器或配置表**：首先，操作系统需要识别并访问关于内存信息的寄存器或配置表。通常，这需要硬件相关的知识和代码。
2. **解析信息**：一旦访问了寄存器或配置表，操作系统需要解析里面的数据以获取关于物理内存的信息，如内存大小、速度、定时参数等。
3. **映射到系统内存管理**：获取的信息可以直接用于系统的内存管理任务，如物理内存分配、虚拟内存映射等。

### 4.交互的方式

1. **查询虚拟机管理器 (VMM) 的API**：许多VMM都提供了APIs，供宾客操作系统查询关于其虚拟环境的信息。例如，VMware的VMTools或Hyper-V的集成服务。

2. **使用Paravirtualization技术**：在此方法中，宾客操作系统知道它在虚拟环境中运行，并直接与VMM交互来获取关于虚拟硬件的信息。

3. **与宿主操作系统交互**：当在容器中运行时，可以直接查询宿主操作系统来获取所需的信息，例如通过/proc或/sys文件系统。